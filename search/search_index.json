{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Willkommen zur Dokumentation vom Spiel \"Dreckssau\"","text":""},{"location":"#setup","title":"Setup","text":"<ol> <li>pip install customtkinter</li> <li>pip install tkinter</li> <li>pip install ctkmessagebox</li> <li>git clone (https://github.zhaw.ch/MI25a-PM1-HS25/MI25a-PM1-HS25-G3-P3&gt;)</li> <li>cd src/</li> <li>python -m frontend.control_panel</li> </ol>"},{"location":"#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ul> <li>Anforderung</li> <li>Organisatorische Umsetzung</li> <li>Technische Umsetzung</li> <li>Funktionen</li> <li>Testkonzept</li> <li>Lessons Learned</li> </ul>"},{"location":"#spielanleitung","title":"Spielanleitung","text":"<p>Hier befindet sich die Spielanleitung als PDF-Dokument.</p> <p></p> <p>Das Layout der Dokumentation wurde mithilfe ChatGPT erstellt, darunter geh\u00f6ren \u00c4nderungen im .yml-File sowie die erg\u00e4nzung vom .css-File.*</p>"},{"location":"anforderungen/","title":"Anforderungen","text":""},{"location":"anforderungen/#vision","title":"Vision","text":"<p>Die Vision beschreibt ein \u00fcber die Konsole gesteuertes, textbasiertes Spiel basierend auf dem Kartenspiel Drecksau von Kosmos Spiele. Das Programm soll \u00fcber Ein- und Ausgabe in der Konsole vollst\u00e4ndig steuerbar sein und folgende Funktionalit\u00e4ten enthalten:</p> <ul> <li>Ein textbasiertes Spiel f\u00fcr 2\u20134 Spieler starten</li> <li>Die Karten jedes Spielers anzeigen</li> <li>Die ausliegenden Karten auf dem Tisch nach jedem Zug anzeigen</li> <li>Das Ziehen und Ausspielen von Karten erm\u00f6glichen</li> <li>Die offiziellen Spielregeln vollst\u00e4ndig umsetzen</li> <li>Die Spielmechanik modular strukturieren (Backend, Frontend, Logik)</li> <li>Eine selbst gew\u00e4hlte Spielerweiterung implementieren   (z. B. neue Aktionskarte, alternative Kartenwirkungen, zus\u00e4tzliche Regeln)</li> <li>Ung\u00fcltige Eingaben, Zugfehler oder Spielregelverletzungen sollen professionell behandelt werden</li> <li>Das Spiel kann sauber beendet werden</li> </ul>"},{"location":"anforderungen/#user-stories-akzeptanzkriterien","title":"User Stories &amp; Akzeptanzkriterien","text":"<p>Die User Stories und die Akzeptanzkriterien k\u00f6nnen im Jira-Board eingesehen werden.</p> <p>Diese dienen als Grundlage f\u00fcr:</p> <ul> <li> <p>die Aufgabenteilung im Team,</p> </li> <li> <p>die Sprintplanung,</p> </li> <li> <p>die Funktionsbl\u00f6cke (Backend, Frontend, Logik),</p> </li> <li> <p>sowie die sp\u00e4tere Implementierung und Testabdeckung.</p> </li> </ul>"},{"location":"funktionen/","title":"Funktionen","text":""},{"location":"funktionen/#entry-point","title":"Entry Point","text":"<p>Hier sieht ihr eine Auflistung unserer Funktionen vom Code. Die Autoren und weitere Angaben bez\u00fcglich den Arbeitsablauf, befinden sich auf Jira.</p> Backend Frontend Logik"},{"location":"funktionen/#backend.action_clean","title":"<code>action_clean</code>","text":""},{"location":"funktionen/#backend.action_clean.action_clean","title":"<code>action_clean(dictionary: dict, pig_number: str) -&gt; dict</code>","text":"<p>Die Funktion tr\u00e4gt in einem W\u00f6rterbuch ein, dass ein bestimmtes Schwein jetzt als \u201eclean\u201c markiert ist.</p> Source code in <code>src\\backend\\action_clean.py</code> <pre><code>def action_clean(dictionary: dict, pig_number: str) -&gt; dict:\n    \"\"\"\n    Die Funktion tr\u00e4gt in einem W\u00f6rterbuch ein, dass ein bestimmtes Schwein jetzt als \u201eclean\u201c markiert ist.\n    \"\"\"\n    status = dictionary[f\"{pig_number}\"]\n    status = status.replace(\"dirty\", \"clean\")\n    dictionary[f\"{pig_number}\"] = status\n    return dictionary\n</code></pre>"},{"location":"funktionen/#backend.action_flash","title":"<code>action_flash</code>","text":""},{"location":"funktionen/#backend.action_flash.action_flash","title":"<code>action_flash(dictionary: dict, pig_number: str) -&gt; dict</code>","text":"<p>Die Funktion entfernt das Wort \"stable\" aus dem Status eines Schweins und simuliert damit einen Blitz, der den Stall zerst\u00f6rt.</p> Source code in <code>src\\backend\\action_flash.py</code> <pre><code>def action_flash(dictionary: dict, pig_number:str) -&gt; dict:\n    \"\"\"\n    Die Funktion entfernt das Wort \"stable\" aus dem Status eines Schweins und simuliert damit einen Blitz,\n    der den Stall zerst\u00f6rt.\n    \"\"\"\n    status = dictionary[pig_number]\n    if status.startswith(\"clean\"):\n        status = \"clean,\"\n    else:\n        status = \"dirty,\"\n    dictionary[pig_number] = status\n    return dictionary\n</code></pre>"},{"location":"funktionen/#backend.action_stable_locked","title":"<code>action_stable_locked</code>","text":""},{"location":"funktionen/#backend.action_stable_locked.action_stable_locked","title":"<code>action_stable_locked(dictionary: dict, pig_number: str) -&gt; dict</code>","text":"<p>Im Spiel Drecksau bedeutet das Anh\u00e4ngen von \"locked,\", dass der Stall f\u00fcr den Bauer geschlossen bzw. blockiert wird. Das Schwein kann dadurch nicht mehr vom Bauern direkt beeinflusst werden (z.B. nicht sauber gemacht)</p> Source code in <code>src\\backend\\action_stable_locked.py</code> <pre><code>def action_stable_locked(dictionary: dict, pig_number:str) -&gt; dict:\n    \"\"\"\n    Im Spiel Drecksau bedeutet das Anh\u00e4ngen von \"locked,\", dass der Stall f\u00fcr den Bauer geschlossen bzw. blockiert wird.\n    Das Schwein kann dadurch nicht mehr vom Bauern direkt beeinflusst werden (z.B. nicht sauber gemacht)\n    \"\"\"\n    status = dictionary[pig_number]\n    status = status + \"locked,\"\n    dictionary[pig_number] = status\n    return dictionary\n</code></pre>"},{"location":"funktionen/#backend.action_stable_open","title":"<code>action_stable_open</code>","text":""},{"location":"funktionen/#backend.action_stable_open.action_stable_open","title":"<code>action_stable_open(dictionary: dict, pig_number: str)</code>","text":"<p>Die Funktion action_stable_open(dictionary, pig_number) pr\u00fcft, ob ein bestimmtes Schwein im \u00fcbergebenen Dictionary den Status \"locked\" hat. Falls der Stall abgeschlossen ist, wird keine Aktion ausgef\u00fchrt. Falls der Stall nicht abgeschlossen ist, wird das Dictionary \u00fcber action_clean() weiterverarbeitet (das Schwein wird gereinigt) und anschlie\u00dfend zur\u00fcckgegeben.</p> Source code in <code>src\\backend\\action_stable_open.py</code> <pre><code>def action_stable_open(dictionary: dict, pig_number: str):\n    \"\"\"\n    Die Funktion action_stable_open(dictionary, pig_number) pr\u00fcft,\n    ob ein bestimmtes Schwein im \u00fcbergebenen Dictionary den Status \"locked\" hat.\n    Falls der Stall abgeschlossen ist, wird keine Aktion ausgef\u00fchrt.\n    Falls der Stall nicht abgeschlossen ist, wird das Dictionary \u00fcber action_clean() weiterverarbeitet\n    (das Schwein wird gereinigt) und anschlie\u00dfend zur\u00fcckgegeben.\"\"\"\n\n    status = dictionary[pig_number]\n    if 'locked' in status:\n        return None\n    else:\n        dictionary = action_clean(dictionary, pig_number)\n        return dictionary\n</code></pre>"},{"location":"funktionen/#backend.action_tornado","title":"<code>action_tornado</code>","text":""},{"location":"funktionen/#backend.action_tornado.action_tornado","title":"<code>action_tornado(dict_all_players)</code>","text":"<p>F\u00fchrt die Aktion Tornado aus, welche die Aktionskarten der jeweiligen Schweine durchmischt. Der Sauberkeitsgrad der Schweine bleibt jedoch bestehen. Es ist durchaus m\u00f6glich, dass der Tornado die Aktionskarten eines Schweins zuf\u00e4lligerweise dem gleichen Schwein zuordnet.</p>"},{"location":"funktionen/#backend.action_tornado.action_tornado--parameters","title":"Parameters","text":"<p>dict_all_players : lists of dictionaries     Liste mit den Dictionaries aller Spieler.</p>"},{"location":"funktionen/#backend.action_tornado.action_tornado--returns","title":"Returns","text":"<p>dict_all_players : lists of dictionaries     Liste mit den Dictionaries aller Spieler.</p> Source code in <code>src\\backend\\action_tornado.py</code> <pre><code>def action_tornado(dict_all_players):\n    \"\"\"\n    F\u00fchrt die Aktion Tornado aus, welche die Aktionskarten der jeweiligen\n    Schweine durchmischt. Der Sauberkeitsgrad der Schweine bleibt jedoch\n    bestehen. Es ist durchaus m\u00f6glich, dass der Tornado die Aktionskarten\n    eines Schweins zuf\u00e4lligerweise dem gleichen Schwein zuordnet.\n\n    Parameters\n    ----------\n    dict_all_players : lists of dictionaries\n        Liste mit den Dictionaries aller Spieler.\n\n    Returns\n    -------\n    dict_all_players : lists of dictionaries\n        Liste mit den Dictionaries aller Spieler.\n\n    \"\"\"\n    # Zwischenspeicher f\u00fcr alle Aktionen im Spiel\n    all_action_items = []\n\n    # Alle momentanen Aktionen der Schweine erhalten:\n    for player_dict in dict_all_players:\n        # Wir m\u00f6chten nur die Aktionen eines Schweins \u00e4ndern und nicht sein\n        # Sauberkeitszustand\n        all_action_items += [action.split(',')[1:] for action in list(player_dict.values())]\n\n    # Aktionen der Schweine neu zuordnen:\n    for player_dict in dict_all_players:\n        for pig in player_dict:\n            # L\u00f6scht die momentanen Aktionen des jeweiligen Schweins\n            player_dict[pig] = player_dict[pig].split(',')[0]\n            # W\u00e4hlt die zuf\u00e4lligen (neuen) Aktion(en) des Schweins\n            new_action = random.choice(all_action_items)\n            all_action_items.remove(new_action)\n            # Da alle Werte als Listen abgespeichert sind\n            for action in new_action:\n                player_dict[pig] += \",\" + action\n\n    return dict_all_players\n</code></pre>"},{"location":"funktionen/#backend.create_dictionary","title":"<code>create_dictionary</code>","text":""},{"location":"funktionen/#backend.create_dictionary.create_dictionary","title":"<code>create_dictionary(number)</code>","text":"<p>Die Funktion gibt je nach Spieler Anzahl ein passendes Dictionary zur\u00fcck.</p> Source code in <code>src\\backend\\create_dictionary.py</code> <pre><code>def create_dictionary(number):\n    \"\"\"\n    Die Funktion gibt je nach Spieler Anzahl ein passendes Dictionary zur\u00fcck.\n    \"\"\"\n\n    if number == 2:\n        return dict_2\n    elif number == 3:\n        return dict_3\n    elif number == 4:\n        return dict_4\n    elif number == 123:     # Test-dictionary wird abgerufen.\n        return dict_test\n    return None\n</code></pre>"},{"location":"funktionen/#backend.create_players_list","title":"<code>create_players_list</code>","text":""},{"location":"funktionen/#backend.function_current_arrester","title":"<code>function_current_arrester</code>","text":""},{"location":"funktionen/#backend.function_current_arrester.action_current_arrester","title":"<code>action_current_arrester(dictionary: dict, pig_number: str) -&gt; dict</code>","text":"<p>F\u00fcgt einem Schwein einen Blitzableiter hinzu, wenn es sich in einem Stall befindet. Der Blitzableiter sch\u00fctzt das Schwein vor zuk\u00fcnftigen Blitz-Aktionen.</p>"},{"location":"funktionen/#backend.function_current_arrester.action_current_arrester--parameters","title":"Parameters","text":"<p>dictionary : dict     Ein Dictionary, das Schweine ihren Status-Strings (Values) zuordnet. pig_number : str     Die ID des Schweins, dem ein Blitzableiter hinzugef\u00fcgt werden soll.</p>"},{"location":"funktionen/#backend.function_current_arrester.action_current_arrester--returns","title":"Returns","text":"<p>dict     Das aktualisierte Dictionary mit erweitertem Status f\u00fcr das angegebene Schwein.</p> Source code in <code>src\\backend\\function_current_arrester.py</code> <pre><code>def action_current_arrester(dictionary: dict, pig_number: str) -&gt; dict:\n    \"\"\"\n    F\u00fcgt einem Schwein einen Blitzableiter hinzu, wenn es sich in einem Stall befindet.\n    Der Blitzableiter sch\u00fctzt das Schwein vor zuk\u00fcnftigen Blitz-Aktionen.\n\n    Parameters\n    ----------\n    dictionary : dict\n        Ein Dictionary, das Schweine ihren Status-Strings (Values) zuordnet.\n    pig_number : str\n        Die ID des Schweins, dem ein Blitzableiter hinzugef\u00fcgt werden soll.\n\n    Returns\n    -------\n    dict\n        Das aktualisierte Dictionary mit erweitertem Status f\u00fcr das angegebene Schwein.\n\n    \"\"\"\n\n    status = dictionary[pig_number]\n\n    # current_arrester hinzuf\u00fcgen\n    dictionary[pig_number] = status + \"current_arrester,\"\n\n    return dictionary\n</code></pre>"},{"location":"funktionen/#backend.function_dirty","title":"<code>function_dirty</code>","text":""},{"location":"funktionen/#backend.function_dirty.action_dirty","title":"<code>action_dirty(dictionary: dict, pig_number: str) -&gt; dict</code>","text":"<p>Die Funktion tr\u00e4gt in einem W\u00f6rterbuch ein, dass ein bestimmtes Schwein jetzt als \u201edirty\u201c markiert ist.</p> Source code in <code>src\\backend\\function_dirty.py</code> <pre><code>def action_dirty(dictionary: dict, pig_number: str) -&gt; dict:\n    \"\"\"\n    Die Funktion tr\u00e4gt in einem W\u00f6rterbuch ein, dass ein bestimmtes Schwein jetzt als \u201edirty\u201c markiert ist.\n    \"\"\"\n    status = dictionary[pig_number]\n    status = status.replace('clean', 'dirty')\n    dictionary[pig_number] = status\n    return dictionary\n</code></pre>"},{"location":"funktionen/#backend.function_stable","title":"<code>function_stable</code>","text":""},{"location":"funktionen/#backend.function_stable.action_stable","title":"<code>action_stable(dictionary: dict, pig_number: str) -&gt; dict</code>","text":"<p>Im Spiel Drecksau bedeutet das Anh\u00e4ngen von \"stable,\", dass ein offener Stall f\u00fcr das Schwei geabut wurde. Das Schwein kann dadurch nicht mehr vom Regen beeinflusst werden (z.B. nicht sauber gemacht werden)</p> Source code in <code>src\\backend\\function_stable.py</code> <pre><code>def action_stable(dictionary: dict, pig_number:str) -&gt; dict:\n    \"\"\"\n    Im Spiel Drecksau bedeutet das Anh\u00e4ngen von \"stable,\", dass ein offener Stall f\u00fcr das Schwei geabut wurde.\n    Das Schwein kann dadurch nicht mehr vom Regen beeinflusst werden (z.B. nicht sauber gemacht werden)\n    \"\"\"\n    status = dictionary[pig_number]\n    status = status + \"stable,\"\n    dictionary[pig_number] = status\n    return dictionary\n</code></pre>"},{"location":"funktionen/#backend.funktion_rain","title":"<code>funktion_rain</code>","text":""},{"location":"funktionen/#backend.funktion_rain.action_rain","title":"<code>action_rain(list_of_dictionaries)</code>","text":"<p>Mit der Regenkarte werden alle Schweine wieder sauber, ausser diese sind in einem Stall.</p>"},{"location":"funktionen/#backend.funktion_rain.action_rain--parameters","title":"Parameters","text":"<p>list_of_dictionaries : Liste     Eine Liste von Dictionaries, jedes Dictionary enth\u00e4lt die \"pigs\"</p>"},{"location":"funktionen/#backend.funktion_rain.action_rain--returns","title":"Returns","text":"<p>list_of_dictionaries : Liste     Die aktualisierte Liste mit Dictionaires nach der Anwendung der Regenkarte.</p> Source code in <code>src\\backend\\funktion_rain.py</code> <pre><code>def action_rain(list_of_dictionaries):\n    \"\"\"\n    Mit der Regenkarte werden alle Schweine wieder sauber, ausser diese sind in einem Stall.\n\n    Parameters\n    ----------\n    list_of_dictionaries : Liste\n        Eine Liste von Dictionaries, jedes Dictionary enth\u00e4lt die \"pigs\"\n\n    Returns\n    -------\n    list_of_dictionaries : Liste\n        Die aktualisierte Liste mit Dictionaires nach der Anwendung der Regenkarte.\n\n    \"\"\"\n    for dictionary in list_of_dictionaries:\n        for pig_number, status in dictionary.items():\n            # Schwein bleibt unver\u00e4ndert, wenn es im Stall ist\n            if 'stable' in status:\n                continue\n\n            # Ansonsten: 'dirty' -&gt; 'clean'\n            status = status.replace('dirty', 'clean')\n            dictionary[pig_number] = status\n\n    return list_of_dictionaries\n</code></pre>"},{"location":"funktionen/#frontend.config","title":"<code>config</code>","text":""},{"location":"funktionen/#frontend.control_panel","title":"<code>control_panel</code>","text":""},{"location":"funktionen/#frontend.control_panel.parse_widget_to_pig_location","title":"<code>parse_widget_to_pig_location(widget)</code>","text":"<p>Helper function to receive the player-number and the pig-number of the selected pigs more gently</p> Source code in <code>src\\frontend\\control_panel.py</code> <pre><code>def parse_widget_to_pig_location(widget):\n    \"\"\"\n    Helper function to receive the player-number and the pig-number of the selected pigs\n    more gently \n    \"\"\"\n    return_values = {\n        \"player_number\": 0,\n        \"pig_number\": 0\n    }\n    for part_of_name in str(widget).split('.'):\n        if \"pigs_player\" in part_of_name:\n            return_values[\"player_number\"] = part_of_name[-1]\n        elif \"ctkbutton\" in part_of_name:\n            return_values[\"pig_number\"] = widget.flag\n    return return_values\n</code></pre>"},{"location":"funktionen/#frontend.manage_action_cards","title":"<code>manage_action_cards</code>","text":""},{"location":"funktionen/#frontend.manage_pigs","title":"<code>manage_pigs</code>","text":""},{"location":"funktionen/#frontend.manage_support_cards","title":"<code>manage_support_cards</code>","text":""},{"location":"funktionen/#logik.check_action_clean","title":"<code>check_action_clean</code>","text":""},{"location":"funktionen/#logik.check_action_clean.check_clean","title":"<code>check_clean(dictionary: dict, pig_number: str) -&gt; int</code>","text":"<p>Die Check clean Funktion \u00fcberpr\u00fcft, ob ein Schwein sauber  werden kann oder nicht. z.B. bei Regen oder im Stall...</p>"},{"location":"funktionen/#logik.check_action_clean.check_clean--parameters","title":"Parameters","text":"<p>dictionary : dict     Ein Dictionary, das jedem Schwein (Key) einen Status-String     zuordnet. Der Status enth\u00e4lt Informationen wie 'dirty',     'clean', 'stable', 'locked' usw. pig_number : str     Die ID des Schweins, f\u00fcr das \u00fcberpr\u00fcft werden soll, ob die     Reinigung durchgef\u00fchrt werden darf.</p>"},{"location":"funktionen/#logik.check_action_clean.check_clean--returns","title":"Returns","text":"<p>int     -1 : Fehler \u2013 das Schwein befindet sich im Stall ('stable') und          kann nicht sauber gemacht werden.     1 : Warning \u2013 das Schwein ist bereits sauber ('clean').     0 : OK \u2013 das Schwein ist dreckig ('dirty') und nicht im Stall,          daher darf die Reinigung durchgef\u00fchrt werden.</p> Source code in <code>src\\logik\\check_action_clean.py</code> <pre><code>def check_clean(dictionary: dict, pig_number: str) -&gt; int:\n    \"\"\"\n    Die Check clean Funktion \u00fcberpr\u00fcft, ob ein Schwein sauber \n    werden kann oder nicht. z.B. bei Regen oder im Stall...\n\n    Parameters\n    ----------\n    dictionary : dict\n        Ein Dictionary, das jedem Schwein (Key) einen Status-String\n        zuordnet. Der Status enth\u00e4lt Informationen wie 'dirty',\n        'clean', 'stable', 'locked' usw.\n    pig_number : str\n        Die ID des Schweins, f\u00fcr das \u00fcberpr\u00fcft werden soll, ob die\n        Reinigung durchgef\u00fchrt werden darf.\n\n    Returns\n    -------\n    int\n        -1 : Fehler \u2013 das Schwein befindet sich im Stall ('stable') und\n             kann nicht sauber gemacht werden.\n        1 : Warning \u2013 das Schwein ist bereits sauber ('clean').\n        0 : OK \u2013 das Schwein ist dreckig ('dirty') und nicht im Stall,\n             daher darf die Reinigung durchgef\u00fchrt werden.\n\n    \"\"\"\n\n    status = dictionary[pig_number]\n\n    # wenn im Stall, dann nicht m\u00f6glich\n    if \"stable\" in status:\n        return -1\n    # wenn bereits sauber, macht es keinen Sinn\n    if \"clean\" in status:\n        return 1\n\n    # wenn dirty + nicht im Stall = clean i.O.\n    return 0\n</code></pre>"},{"location":"funktionen/#logik.check_action_current_arrester","title":"<code>check_action_current_arrester</code>","text":""},{"location":"funktionen/#logik.check_action_current_arrester.check_current_arrester","title":"<code>check_current_arrester(dictionary: dict, pig_number: str) -&gt; int</code>","text":"<p>Pr\u00fcft, ob eine 'current_arrester'-Karte auf das angegebene Schwein gelegt werden darf.</p> <p>Bedingungen: - Das Schwein muss sich im Stall befinden ('stable'). - Es darf noch kein 'current_arrester' vorhanden sein.</p>"},{"location":"funktionen/#logik.check_action_current_arrester.check_current_arrester--parameters","title":"Parameters","text":"<p>dictionary : dict     Ein Dictionary, das jedem Schwein (Key) einen Status-String zuordnet.     Der Status-String enth\u00e4lt Informationen wie Sauberkeit und     zus\u00e4tzliche Karten, z. B. 'dirty,stable'. pig_number : str     Die ID des Schweins, f\u00fcr das gepr\u00fcft werden soll, ob eine     'current_arrester'-Karte gelegt werden kann.</p>"},{"location":"funktionen/#logik.check_action_current_arrester.check_current_arrester--returns","title":"Returns","text":"<p>int     0 : Die Karte darf gelegt werden.     1 : Die Karte soll nicht gelegt werden ( weil ein 'current_arrester' existiert).     -1 : Die Karte darf nicht gelegt werden, da kein Stall vorhanden</p> Source code in <code>src\\logik\\check_action_current_arrester.py</code> <pre><code>def check_current_arrester(dictionary: dict, pig_number:str) -&gt; int:\n    \"\"\"\n    Pr\u00fcft, ob eine 'current_arrester'-Karte auf das angegebene Schwein\n    gelegt werden darf.\n\n    Bedingungen:\n    - Das Schwein muss sich im Stall befinden ('stable').\n    - Es darf noch kein 'current_arrester' vorhanden sein.\n\n    Parameters\n    ----------\n    dictionary : dict\n        Ein Dictionary, das jedem Schwein (Key) einen Status-String zuordnet.\n        Der Status-String enth\u00e4lt Informationen wie Sauberkeit und\n        zus\u00e4tzliche Karten, z. B. 'dirty,stable'.\n    pig_number : str\n        Die ID des Schweins, f\u00fcr das gepr\u00fcft werden soll, ob eine\n        'current_arrester'-Karte gelegt werden kann.\n\n    Returns\n    -------\n    int\n        0 : Die Karte darf gelegt werden.\n        1 : Die Karte soll nicht gelegt werden ( weil ein 'current_arrester' existiert).\n        -1 : Die Karte darf nicht gelegt werden, da kein Stall vorhanden\n    \"\"\"\n\n    status = dictionary[pig_number]\n\n    if \"stable\" not in status:\n        return -1\n\n    if \"current_arrester\" in status:\n        return 1\n\n    return 0\n</code></pre>"},{"location":"funktionen/#logik.check_action_flash","title":"<code>check_action_flash</code>","text":""},{"location":"funktionen/#logik.check_action_flash.check_action_flash","title":"<code>check_action_flash(dictionary: dict, pig_number: str) -&gt; int</code>","text":"<p>Der Blitz fackelt den Stall ab. Wenn ein Blitzableiter vorhanden ist,  bringt es nichts. Und wenn es den Stall nicht gibt, kann nicht abge- fackelt werden.</p>"},{"location":"funktionen/#logik.check_action_flash.check_action_flash--parameters","title":"Parameters","text":"<p>dictionary : dict    Ein Dictionary, das jedem Schwein (Key) einen Status-String    zuordnet. Der Status enth\u00e4lt Informationen wie 'dirty',    'clean', 'stable', 'locked', 'current_arrester' usw. pig_number : str    Die ID des Schweins, auf das die Blitzkarte angewendet werden soll.</p>"},{"location":"funktionen/#logik.check_action_flash.check_action_flash--returns","title":"Returns","text":"<p>int     -1 : Fehler \u2013 es ist kein Stall vorhanden, daher kann nichts          abgefackelt werden.      1 : Warning \u2013 ein 'current_arrester' ist vorhanden, der Blitz          zeigt keine Wirkung.      0 : OK \u2013 ein Stall ist vorhanden und kein Blitzableiter sch\u00fctzt;          der Blitz kann gespielt werden.</p> Source code in <code>src\\logik\\check_action_flash.py</code> <pre><code>def check_action_flash(dictionary: dict, pig_number: str) -&gt; int:\n    \"\"\"\n    Der Blitz fackelt den Stall ab. Wenn ein Blitzableiter vorhanden ist, \n    bringt es nichts. Und wenn es den Stall nicht gibt, kann nicht abge-\n    fackelt werden.\n\n    Parameters\n    ----------\n    dictionary : dict\n       Ein Dictionary, das jedem Schwein (Key) einen Status-String\n       zuordnet. Der Status enth\u00e4lt Informationen wie 'dirty',\n       'clean', 'stable', 'locked', 'current_arrester' usw.\n    pig_number : str\n       Die ID des Schweins, auf das die Blitzkarte angewendet werden soll.\n\n    Returns\n    -------\n    int\n        -1 : Fehler \u2013 es ist kein Stall vorhanden, daher kann nichts\n             abgefackelt werden.\n         1 : Warning \u2013 ein 'current_arrester' ist vorhanden, der Blitz\n             zeigt keine Wirkung.\n         0 : OK \u2013 ein Stall ist vorhanden und kein Blitzableiter sch\u00fctzt;\n             der Blitz kann gespielt werden.\n\n    \"\"\"\n    status = dictionary[pig_number]\n\n    # Mit dem Blitableiter wird es abgeleitet, macht keinen Sinn\n    if \"current_arrester\" in status:\n        return 1\n\n    # Wenn Stall nicht im Status, dann kann es nicht gespielt werden\n    if \"stable\" not in status:\n        return -1\n\n    return 0\n</code></pre>"},{"location":"funktionen/#logik.check_action_locked","title":"<code>check_action_locked</code>","text":""},{"location":"funktionen/#logik.check_action_locked.check_action_locked","title":"<code>check_action_locked(dictionary: dict, pig_number: str) -&gt; int</code>","text":"<p>Pr\u00fcft ob eine Locked-Karte gelegt werden kann / darf.</p> <ul> <li>Das Schwein muss sich im Stall befinden.</li> <li>Es soll noch kein \"locked\" vorhanden sein.</li> </ul>"},{"location":"funktionen/#logik.check_action_locked.check_action_locked--parameters","title":"Parameters","text":"<p>dictionary : dict     Ein Dictionary, das jedem Schwein (Key) einen Status-String     zuordnet. Beispiel: 'dirty,stable,'. pig_number : str     Die ID des Schweins, f\u00fcr das gepr\u00fcft werden soll, ob die     'locked'-Karte gelegt werden kann.</p>"},{"location":"funktionen/#logik.check_action_locked.check_action_locked--returns","title":"Returns","text":"<p>int     -1 = Fehler     1 = Warnung     0 = OK</p> Source code in <code>src\\logik\\check_action_locked.py</code> <pre><code>def check_action_locked(dictionary: dict, pig_number: str) -&gt; int:\n    \"\"\"\n    Pr\u00fcft ob eine Locked-Karte gelegt werden kann / darf.\n\n    - Das Schwein muss sich im Stall befinden.\n    - Es soll noch kein \"locked\" vorhanden sein.\n\n    Parameters\n    ----------\n    dictionary : dict\n        Ein Dictionary, das jedem Schwein (Key) einen Status-String\n        zuordnet. Beispiel: 'dirty,stable,'.\n    pig_number : str\n        Die ID des Schweins, f\u00fcr das gepr\u00fcft werden soll, ob die\n        'locked'-Karte gelegt werden kann.\n\n    Returns\n    -------\n    int\n        -1 = Fehler\n        1 = Warnung\n        0 = OK\n\n    \"\"\"\n    status = dictionary[pig_number]\n\n    # Locked kann nur gelegt werden, wenn der Stall vorhanden ist\n    if \"stable\" not in status:\n        return -1\n\n    if \"locked\" in status:\n        return 1\n\n    return 0\n</code></pre>"},{"location":"funktionen/#logik.check_action_open","title":"<code>check_action_open</code>","text":""},{"location":"funktionen/#logik.check_action_open.check_action_open","title":"<code>check_action_open(dictionary: dict, pig_number: str) -&gt; int</code>","text":"<p>Die Karte kann nur gespielt werden, wenn das Schwein dreckig ist. Zu dem kann es aber nicht gewaschen werden, wenn der Stall abgesperrt ist.</p>"},{"location":"funktionen/#logik.check_action_open.check_action_open--parameters","title":"Parameters","text":"<p>dictionary : dict     Ein Dictionary, das jedem Schwein (Key) einen Status-String     zuordnet. Dieser enth\u00e4lt Informationen wie 'clean', 'dirty',     'stable', 'locked' usw. pig_number : str     Die ID des Schweins, f\u00fcr das gepr\u00fcft werden soll, ob die     Reinigungsaktion ausgef\u00fchrt werden darf.</p>"},{"location":"funktionen/#logik.check_action_open.check_action_open--returns","title":"Returns","text":"<p>int     -1 : Fehler \u2013 das Schwein befindet sich in einem 'locked'-Stall        und kann daher nicht gewaschen werden.     1 : Warning \u2013 das Schwein ist bereits 'clean' und muss nicht        gewaschen werden.     0 : OK \u2013 das Schwein ist 'dirty' und darf gewaschen werden.</p> Source code in <code>src\\logik\\check_action_open.py</code> <pre><code>def check_action_open(dictionary: dict, pig_number: str) -&gt; int:\n    \"\"\"\n    Die Karte kann nur gespielt werden, wenn das Schwein dreckig ist.\n    Zu dem kann es aber nicht gewaschen werden, wenn der Stall abgesperrt ist.\n\n    Parameters\n    ----------\n    dictionary : dict\n        Ein Dictionary, das jedem Schwein (Key) einen Status-String\n        zuordnet. Dieser enth\u00e4lt Informationen wie 'clean', 'dirty',\n        'stable', 'locked' usw.\n    pig_number : str\n        Die ID des Schweins, f\u00fcr das gepr\u00fcft werden soll, ob die\n        Reinigungsaktion ausgef\u00fchrt werden darf.\n\n    Returns\n    -------\n    int\n        -1 : Fehler \u2013 das Schwein befindet sich in einem 'locked'-Stall\n           und kann daher nicht gewaschen werden.\n        1 : Warning \u2013 das Schwein ist bereits 'clean' und muss nicht\n           gewaschen werden.\n        0 : OK \u2013 das Schwein ist 'dirty' und darf gewaschen werden.\n\n    \"\"\"\n    status = dictionary[pig_number]\n\n    if \"locked\" in status:\n        return -1\n\n    if \"clean\" in status:\n        return 1\n\n    return 0\n</code></pre>"},{"location":"funktionen/#logik.check_action_stable","title":"<code>check_action_stable</code>","text":""},{"location":"funktionen/#logik.check_action_stable.check_action_stable","title":"<code>check_action_stable(dictionary: dict, pig_number: str) -&gt; int</code>","text":"<p>Pr\u00fcft, ob ein 'stable' (Stall) auf das angegebene Schwein gebaut werden darf.</p> <p>Parameters</p> <p>dictionary : dict      Ein Dictionary, das jedem Schwein (Key) einen Status-String      zuordnet. Beispiel: 'dirty,' oder 'clean,stable,'.  pig_number : str      Die ID des Schweins, das \u00fcberpr\u00fcft werden soll.</p> <p>Returns</p> <p>int       1 : Fehler \u2013 ein Stall ist bereits vorhanden.       0 : OK \u2013 Stall darf gebaut werden.</p> Source code in <code>src\\logik\\check_action_stable.py</code> <pre><code>def check_action_stable(dictionary: dict, pig_number: str) -&gt; int:\n    \"\"\"\n   Pr\u00fcft, ob ein 'stable' (Stall) auf das angegebene Schwein gebaut\n   werden darf.\n\n   Parameters\n    ----------\n    dictionary : dict\n        Ein Dictionary, das jedem Schwein (Key) einen Status-String\n        zuordnet. Beispiel: 'dirty,' oder 'clean,stable,'.\n    pig_number : str\n        Die ID des Schweins, das \u00fcberpr\u00fcft werden soll.\n\n    Returns\n    -------\n    int\n         1 : Fehler \u2013 ein Stall ist bereits vorhanden.\n         0 : OK \u2013 Stall darf gebaut werden.\n    \"\"\"\n    status = dictionary[pig_number]\n\n    if \"stable\" in status:\n       return 1\n\n    return 0\n</code></pre>"},{"location":"funktionen/#logik.check_action_withdraw_cards","title":"<code>check_action_withdraw_cards</code>","text":""},{"location":"funktionen/#logik.check_action_withdraw_cards.check_withdraw_cards","title":"<code>check_withdraw_cards(cards: list, pigs_all_players: dict, current_player: int) -&gt; int</code>","text":"<p>Pr\u00fcft, ob der Spieler mindestens eine seiner aktuell gezogenen  Karten spielen kann.  Regeln: - Wenn mindestens eine Karte spielbar ist -&gt; return 0   (Spieler darf aus seinen Karten w\u00e4hlen) - Wenn KEINE der 3 Karten spielbar ist -&gt; return 1   (Spieler muss Karten abwerfen)</p> <p>Die Funktion ver\u00e4ndert nicht den Spielzustand.</p> <p>Parameters</p> <p>cards : list      Die 3 aktuell gezogenen Karten des Spielers      Beispiel: [\"dirty\", \"flash\", \"stable\"]  pigs : dict      Der aktuelle Zustand aller Schweine des Spielers.      Beispiel: {\"1\": \"dirty,stable,\", \"2\": \"clean,\", ...}</p> <p>Returns</p> <p>int      0 : Mindestens eine Karte ist spielbar (kein Abwerfen n\u00f6tig)     1 : Keine Karte ist spielbar (Spieler muss Karten abwerfen)</p> Source code in <code>src\\logik\\check_action_withdraw_cards.py</code> <pre><code>def check_withdraw_cards(cards: list, pigs_all_players: dict, current_player: int) -&gt; int:\n    \"\"\"\n    Pr\u00fcft, ob der Spieler mindestens eine seiner aktuell gezogenen\n    Karten spielen kann.\n    Regeln:\n   - Wenn mindestens eine Karte spielbar ist -&gt; return 0\n     (Spieler darf aus seinen Karten w\u00e4hlen)\n   - Wenn KEINE der 3 Karten spielbar ist -&gt; return 1\n     (Spieler muss Karten abwerfen)\n\n   Die Funktion ver\u00e4ndert nicht den Spielzustand.\n\n    Parameters\n    ----------\n    cards : list\n        Die 3 aktuell gezogenen Karten des Spielers\n        Beispiel: [\"dirty\", \"flash\", \"stable\"]\n    pigs : dict\n        Der aktuelle Zustand aller Schweine des Spielers.\n        Beispiel: {\"1\": \"dirty,stable,\", \"2\": \"clean,\", ...}\n\n    Returns\n    -------\n    int\n        0 : Mindestens eine Karte ist spielbar (kein Abwerfen n\u00f6tig)\n       1 : Keine Karte ist spielbar (Spieler muss Karten abwerfen)\n\n    \"\"\"\n    for card in cards:\n        if (card in config.status_cards) or (card in config.support_cards):\n            for pig_of_current_player in pigs_all_players[current_player-1]:\n                if card == \"Matschkarte\":\n                    result = check_action_dirty(pigs_all_players[current_player-1], pig_of_current_player)\n                elif card == \"Stallkarte\":\n                    result = check_action_stable(pigs_all_players[current_player-1], pig_of_current_player)\n                elif card == \"Blitzableiterkarte\":\n                    result = check_current_arrester(pigs_all_players[current_player-1], pig_of_current_player)\n                elif card == \"Bauer-\u00e4rgere-dich-Karte\":\n                    result = check_action_locked(pigs_all_players[current_player-1], pig_of_current_player)\n                if result == 0:\n                    return 0\n        else:\n            for index, pigs in enumerate(pigs_all_players):\n                if (index == current_player-1):\n                    continue     \n                for pig_number in pigs.keys():\n                    # Mapping Karte: Check-Funktion\n                    if card == \"Bauer-schrubbt-die-Sau-Karte\":\n                        result = check_action_open(pigs, pig_number)\n                    elif card == \"Blitzkarte\":\n                        result = check_action_flash(pigs, pig_number)\n                    elif card == \"Tornadokarte\" or card == \"Regenkarte\":\n                        result = 0\n                    else:\n                        # unbekannte Karte: ignorieren\n                        continue\n                    if result == 0:\n                        return 0\n\n    # Wenn keine einzige Karte spielbar ist:\n    return 1\n</code></pre>"},{"location":"funktionen/#logik.check_function_dirty","title":"<code>check_function_dirty</code>","text":""},{"location":"funktionen/#logik.check_function_dirty.check_action_dirty","title":"<code>check_action_dirty(dictionary: dict, pig_number: str) -&gt; int</code>","text":"<p>Die Karte dirty kann nur auf ein sauberes Schwein gesetzt werden.</p>"},{"location":"funktionen/#logik.check_function_dirty.check_action_dirty--parameters","title":"Parameters","text":"<p>dictionary : dict     Ein Dictionary, das jedem Schwein (Key) einen Status-String zuordnet.     Beispiel: 'clean,stable,' oder 'dirty,'. pig_number : str     Die ID des Schweins, das \u00fcberpr\u00fcft werden soll.</p>"},{"location":"funktionen/#logik.check_function_dirty.check_action_dirty--returns","title":"Returns","text":"<p>int     1 : Karte darf nicht gelegt werden (Schwein ist bereits 'dirty')     0 : Karte darf gelegt werden (Schwein ist 'clean')</p> Source code in <code>src\\logik\\check_function_dirty.py</code> <pre><code>def check_action_dirty(dictionary: dict, pig_number: str) -&gt; int:\n    \"\"\"\n    Die Karte dirty kann nur auf ein sauberes Schwein gesetzt werden.\n\n    Parameters\n    ----------\n    dictionary : dict\n        Ein Dictionary, das jedem Schwein (Key) einen Status-String zuordnet.\n        Beispiel: 'clean,stable,' oder 'dirty,'.\n    pig_number : str\n        Die ID des Schweins, das \u00fcberpr\u00fcft werden soll.\n\n    Returns\n    -------\n    int\n        1 : Karte darf nicht gelegt werden (Schwein ist bereits 'dirty')\n        0 : Karte darf gelegt werden (Schwein ist 'clean')\n\n    \"\"\"\n\n    status = dictionary[pig_number]\n\n    # Prpfen, ob das Schwein bereits dreckig ist, wenn ja, kann es nicht dreckig werden\n    if \"dirty\" in status:\n        return 1\n\n    return 0\n</code></pre>"},{"location":"funktionen/#logik.check_if_player_won","title":"<code>check_if_player_won</code>","text":""},{"location":"lessonslearned/","title":"Lessons Learned","text":""},{"location":"lessonslearned/#ausblick","title":"Ausblick","text":""},{"location":"lessonslearned/#was-lief-gut","title":"Was lief gut:","text":"<p>Das Projekt \u201eDrecksau\u201c war ein komplexes, interaktives Spielprojekt mit vielen Komponenten \u2013 von der Logik der Spielaktionen \u00fcber das Management von Karten und Schweinen bis hin zum Frontend mit Tkinter/CustomTkinter. Insgesamt l\u00e4sst sich das Projekt als erfolgreich und lehrreich zusammenfassen. Das Projekt wurde im Team umgesetzt, kompetitiv, aber dennoch gut strukturiert. Alle Teammitglieder haben aktiv beigetragen, Aufgaben klar verteilt, was den Fortschritt beschleunigt hat.~ Marina S.</p> <p>Ich fand das Projekt echt spannend, da es auch eine gewisse Komplexit\u00e4t mit sich gebracht hat. Es waren viele neue Inhalte dabei, aber trotzdem super interessant. Mega cool zu sehen, wie am Ende alle Funktionen zusammenkommen und das fertige Produkt entsteht. Im Team lief es soweit auch gut \u2013 wir konnten uns super gegenseitig unterst\u00fctzen und dadurch besser weiterkommen. ~ Laura M.</p> <p>Das Projekt ansich fand ich sehr spannend da es Herausforderungen mitsich brachte und ich so neue Erfahrungen in der Informatik sammeln konnte, vorallem im Bereich was automatisiertes dokumentieren angeht. Zuvor kam ich noch nie mit dem in Ber\u00fchrung und musste so von Null starten, ausserdem hatte ich Freude bei der Arbeit.~Amer P.</p> <p>Ich fand es gut dass wir uns herausgefordert haben und wir uns nicht mit den Grundanforderungen zufrieden gaben. Zudem freute es mich, dass wir mehr Freiheiten aufgrund mehr Konstrukten hatten. Schlussendlich genoss ich die Flexibilit\u00e4t, welche mit dem hybriden (offline / online) Modell gew\u00e4hrleistet war. ~Lucien L.</p>"},{"location":"lessonslearned/#was-lief-nicht-gut","title":"Was lief nicht gut:","text":"<p>Durch das umfangreiche Mocking hat das Schreiben der Tests mehr Zeit in Anspruch genommen als urspr\u00fcnglich geplant \u2013 eine interessante Erfahrung, die mir gezeigt hat, wie viel Detailarbeit hinter Unit-Tests steckt. ~ Marina S.</p> <p>Da ich noch nicht so viel Erfahrung im Programmieren habe, war es teilweise etwas schwierig, die gesamte Logik auf Anhieb zu verstehen. Aber mit der Hilfe vom Team war auch das gut machbar. ~ Laura M.</p> <p>Meiner Meinung gibt es nicht viel zu bem\u00e4ngeln, ausser das das Projekt ziemlich Aufw\u00e4ndig war im Vergleich zu den letzten zwei Projekten, jedoch konnten wir die H\u00fcrde erfolgreich meistern.~Amer P.</p> <p>Ich habe teilweise das GUI untersch\u00e4tzt. Die Anordnungen oder das Zusammenspiel der Module war schwieriger als gedacht.~Lucien L. </p>"},{"location":"oru/","title":"Scrum Artefakte","text":""},{"location":"oru/#reviewers","title":"Reviewers","text":"<p>Wir haben uns im Team darauf geeinigt, dass ein Pull Request immer mindestens zwei Approvals ben\u00f6tigt, bevor der jeweilige Pull Request gemergt werden kann. Dies haben wir mittels des Branch Rulesets realisiert.</p>"},{"location":"oru/#scrum-protokolle","title":"Scrum-Protokolle","text":"<p>Die Scrum Protokolle k\u00f6nnen unter diesem Link aufgerufen werden. Dort befindet sich die Definition of Done, sowie weitere Informationen bez\u00fcglich der organisatorischen Umsetzung von unserem Projekt.</p>"},{"location":"oru/#planung","title":"Planung","text":"<p>Wir haben geplant zuerst alle geforderten Funktionen auf jeweilige Branches zu entwickeln und diese dann auf einen separaten Branch (developer) zu mergen.  Sobald das finale Produkt auf \"developer\" erreicht wird, wird alles auf den Hauptbranch \"main\" gemergt.</p> <p>Zudem haben wir vereinbart, dass der Code an sich (Variablennamen, etc.) auf Englisch sein soll, wobei die Kommentare der deutschen Sprache angegliedert werden sollen.  Die Variablen- und Funktionsnamen sollten zudem im Snake-Case geschrieben werden. (Weitere Clean-Coding-Punkte sind unten zu finden)</p> <p>Des Weiteren haben wir uns freiwillig entschieden ein GUI f\u00fcr unser Spiel zu verwenden, da es f\u00fcr eine bessere Spiel\u00fcbersicht sorgt und das Spielen an sich so mehr Spass macht.</p> <p>Zu guter Letzt haben wir vereinbart, dass (bis auf \"developer\") alle Branches die Namen der jeweiligen UserStory (falls vorhanden) tragen sollen.</p>"},{"location":"oru/#clean-coding","title":"Clean-Coding","text":"<p>Bei diesem Projekt haben wir uns an die Clean-Coding-Richtlinien gehalten welche auf Moodle abgelegt wurden. Hier befindet sich das Dokument, welches auf Moodle abgelegt ist.</p>"},{"location":"oru/#quellen","title":"Quellen","text":"<p>Branch Ruleset(3.12.2025)</p> <p>Sneakcase(3.12.2025)</p>"},{"location":"testkonzept/","title":"Testkonzept","text":""},{"location":"testkonzept/#backend-und-logiktests","title":"Backend- und Logiktests","text":"<p>Dieses Testkonzept beschreibt die systematische Pr\u00fcfung der Spiel-Backend- und Logikkomponenten des Spiels Drecksau, das in Python unter Verwendung von tkinter entwickelt wird. Der Fokus liegt auf deterministischer, reproduzierbarer und automatisierter Validierung der spielrelevanten Kernfunktionalit\u00e4t \u2013 unabh\u00e4ngig von der grafischen Benutzeroberfl\u00e4che.</p> <p>Methodik: Alle Tests werden mit pytest ausgef\u00fchrt. Testtiefe: Unit-Tests sichern jede Funktion ab.</p>"},{"location":"testkonzept/#frontend-tests","title":"Frontend Tests","text":"<p>Das Frontend-Testkonzept \u00fcberpr\u00fcft die korrekte Verwaltung von Support-Karten in der GUI unabh\u00e4ngig von der tats\u00e4chlichen Darstellung. Dabei werden alle GUI-Elemente und Bildoperationen durch Mocks ersetzt, sodass die isoliert getestet werden k\u00f6nnen. Ziel ist es sicherzustellen, dass Funktionalit\u00e4t der Kartenverwaltung im Frontend korrekt ist. Methodik: Alle Tests werden mit pytest ausgef\u00fchrt. Testtiefe: Unit Tests mit Mocking. Alle GUI-Komponenten (CTk, CTkLabel, Frame, Image.open, ImageTk.PhotoImage) werden gemockt, damit die Tests headless und schnell laufen.</p> <ul> <li> <p>Fixtures:</p> <ul> <li>root_window: simuliertes Hauptfenster f\u00fcr Spieler-Frames.</li> <li>mock_gui_elements: globale Mocks f\u00fcr GUI-Klassen und Bilder.</li> </ul> </li> <li> <p>Fokus: Logik der Frontend-Funktionen unabh\u00e4ngig von der tats\u00e4chlichen GUI-Bibliothek testen.</p> </li> </ul>"},{"location":"testkonzept/#control_panelpy","title":"control_panel.py","text":"<p>control_panel.py kann nicht direkt getestet werden, weil beim Import sofort Pop-Ups und das Hauptfenster gestartet werden. Die mainloop() blockiert die Ausf\u00fchrung von Tests. Fast alle Funktionen greifen direkt auf globale GUI-Objekte zu. Globale Variablen wie current_player und Spieler-Dictionaries erschweren die Isolation der Logik.</p>"},{"location":"testkonzept/#testprotokoll","title":"Testprotokoll","text":"<p>Hier befindet sich das PDF vom Testprotokoll. Darunter sieht ihr Bilder zuden Test-Resultaten.</p>"},{"location":"testkonzept/#test-resultate","title":"Test-Resultate:","text":"Test-Funktionen:"},{"location":"testkonzept/#tests.conftest","title":"<code>conftest</code>","text":""},{"location":"testkonzept/#tests.test_action_clean","title":"<code>test_action_clean</code>","text":""},{"location":"testkonzept/#tests.test_action_clean.test_action_clean_marks_pig_as_clean","title":"<code>test_action_clean_marks_pig_as_clean()</code>","text":"<p>Das Schwein wird korrekt als 'clean' markiert.</p> Source code in <code>src\\tests\\test_action_clean.py</code> <pre><code>def test_action_clean_marks_pig_as_clean():\n    \"\"\"Das Schwein wird korrekt als 'clean' markiert.\"\"\"\n    data = {\"pig1\": \"dirty\", \"pig2\": \"dirty\"}\n    result = action_clean(data, \"pig1\")\n    assert result[\"pig1\"] == \"clean\"\n</code></pre>"},{"location":"testkonzept/#tests.test_action_clean.test_action_clean_overwrites_existing_state","title":"<code>test_action_clean_overwrites_existing_state()</code>","text":"<p>Auch wenn ein Schwein schon einen anderen Zustand hat, wird es nicht \u00fcberschrieben.</p> Source code in <code>src\\tests\\test_action_clean.py</code> <pre><code>def test_action_clean_overwrites_existing_state():\n    \"\"\"Auch wenn ein Schwein schon einen anderen Zustand hat, wird es nicht \u00fcberschrieben.\"\"\"\n    data = {\"pig3\": \"muddy\"}\n    result = action_clean(data, \"pig3\")\n    assert result[\"pig3\"] == \"muddy\"\n</code></pre>"},{"location":"testkonzept/#tests.test_action_flash","title":"<code>test_action_flash</code>","text":""},{"location":"testkonzept/#tests.test_action_flash.test_action_flash_overwrites_existing_state","title":"<code>test_action_flash_overwrites_existing_state()</code>","text":"<p>Auch wenn ein Schwein schon einen anderen Zustand hat, wird er \u00fcberschrieben.</p> Source code in <code>src\\tests\\test_action_flash.py</code> <pre><code>def test_action_flash_overwrites_existing_state():\n    \"\"\"Auch wenn ein Schwein schon einen anderen Zustand hat, wird er \u00fcberschrieben.\"\"\"\n    data = dict_test.copy()\n    result = action_flash(data, 'pig_3')\n    assert result['pig_3'] == 'dirty,'\n</code></pre>"},{"location":"testkonzept/#tests.test_action_flash.test_action_flash_preserves_other_pigs","title":"<code>test_action_flash_preserves_other_pigs()</code>","text":"<p>Andere Schweine im Dictionary bleiben unver\u00e4ndert.</p> Source code in <code>src\\tests\\test_action_flash.py</code> <pre><code>def test_action_flash_preserves_other_pigs():\n    \"\"\"Andere Schweine im Dictionary bleiben unver\u00e4ndert.\"\"\"\n    data = dict_test.copy()\n    result = action_flash(data, 'pig_2')\n    # Alle anderen Keys ausser pig_2 sollten unver\u00e4ndert bleiben\n    for key in data:\n        if key != 'pig_2':\n            assert result[key] == data[key]\n</code></pre>"},{"location":"testkonzept/#tests.test_action_stabel_locked","title":"<code>test_action_stabel_locked</code>","text":""},{"location":"testkonzept/#tests.test_action_stabel_locked.test_action_stable_locked_appends_locked","title":"<code>test_action_stable_locked_appends_locked()</code>","text":"<p>Das Wort 'locked,' wird korrekt an den Status angeh\u00e4ngt.</p> Source code in <code>src\\tests\\test_action_stabel_locked.py</code> <pre><code>def test_action_stable_locked_appends_locked():\n    \"\"\"Das Wort 'locked,' wird korrekt an den Status angeh\u00e4ngt.\"\"\"\n    data = dict_test.copy()\n    result = action_stable_locked(data, 'pig_1')\n    assert result['pig_1'].endswith('locked,')\n</code></pre>"},{"location":"testkonzept/#tests.test_action_stabel_locked.test_action_stable_locked_preserves_existing_status","title":"<code>test_action_stable_locked_preserves_existing_status()</code>","text":"<p>Der bestehende Status bleibt erhalten und 'locked,' wird angeh\u00e4ngt.</p> Source code in <code>src\\tests\\test_action_stabel_locked.py</code> <pre><code>def test_action_stable_locked_preserves_existing_status():\n    \"\"\"Der bestehende Status bleibt erhalten und 'locked,' wird angeh\u00e4ngt.\"\"\"\n    data = dict_test.copy()\n    result = action_stable_locked(data, 'pig_3')\n    # Vorher war 'dirty, stable, ' \u2192 nachher sollte 'dirty, stable, locked,'\n    assert result['pig_3'] == 'dirty, stable, locked,'\n</code></pre>"},{"location":"testkonzept/#tests.test_action_stabel_locked.test_action_stable_locked_preserves_other_pigs","title":"<code>test_action_stable_locked_preserves_other_pigs()</code>","text":"<p>Andere Schweine im Dictionary bleiben unver\u00e4ndert.</p> Source code in <code>src\\tests\\test_action_stabel_locked.py</code> <pre><code>def test_action_stable_locked_preserves_other_pigs():\n    \"\"\"Andere Schweine im Dictionary bleiben unver\u00e4ndert.\"\"\"\n    data = dict_test.copy()\n    result = action_stable_locked(data, 'pig_2')\n    for key in data:\n        if key != 'pig_2':\n            assert result[key] == data[key]\n</code></pre>"},{"location":"testkonzept/#tests.test_action_stable_open","title":"<code>test_action_stable_open</code>","text":""},{"location":"testkonzept/#tests.test_action_stable_open.test_action_stable_open_preserves_other_pigs","title":"<code>test_action_stable_open_preserves_other_pigs()</code>","text":"<p>Andere Schweine bleiben unver\u00e4ndert, wenn ein Schwein gereinigt wird.</p> Source code in <code>src\\tests\\test_action_stable_open.py</code> <pre><code>def test_action_stable_open_preserves_other_pigs():\n    \"\"\"Andere Schweine bleiben unver\u00e4ndert, wenn ein Schwein gereinigt wird.\"\"\"\n    data = dict_test.copy()\n    result = action_stable_open(data, 'pig_3')\n    for key in data:\n        if key != 'pig_3':\n            assert result[key] == data[key]\n</code></pre>"},{"location":"testkonzept/#tests.test_action_stable_open.test_action_stable_open_unlocked_pig_cleaned","title":"<code>test_action_stable_open_unlocked_pig_cleaned()</code>","text":"<p>Wenn das Schwein nicht 'locked' hat, wird es von action_clean gereinigt.</p> Source code in <code>src\\tests\\test_action_stable_open.py</code> <pre><code>def test_action_stable_open_unlocked_pig_cleaned():\n    \"\"\"Wenn das Schwein nicht 'locked' hat, wird es von action_clean gereinigt.\"\"\"\n    data = dict_test.copy()\n    result = action_stable_open(data, 'pig_2')\n    assert result['pig_2'] == 'clean,'\n</code></pre>"},{"location":"testkonzept/#tests.test_action_tornado","title":"<code>test_action_tornado</code>","text":""},{"location":"testkonzept/#tests.test_action_tornado.test_tornado_all_actions_used","title":"<code>test_tornado_all_actions_used()</code>","text":"<p>Alle urspr\u00fcnglichen Aktionen tauchen wieder irgendwo auf.</p> Source code in <code>src\\tests\\test_action_tornado.py</code> <pre><code>def test_tornado_all_actions_used():\n    \"\"\"Alle urspr\u00fcnglichen Aktionen tauchen wieder irgendwo auf.\"\"\"\n    data = copy.deepcopy(dict_test_players)\n    result = action_tornado(data)\n    all_orig_actions = []\n    for player in dict_test_players:\n        for val in player.values():\n            all_orig_actions += val.split(',')[1:]\n\n    all_result_actions = []\n    for player in result:\n        for val in player.values():\n            all_result_actions += val.split(',')[1:]\n\n    # Sortiert vergleichen, da Reihenfolge durch Tornado randomisiert ist\n    assert sorted(all_orig_actions) == sorted(all_result_actions)\n</code></pre>"},{"location":"testkonzept/#tests.test_action_tornado.test_tornado_preserves_clean_status","title":"<code>test_tornado_preserves_clean_status()</code>","text":"<p>Der Sauberkeitsstatus der Schweine bleibt unver\u00e4ndert.</p> Source code in <code>src\\tests\\test_action_tornado.py</code> <pre><code>def test_tornado_preserves_clean_status():\n    \"\"\"Der Sauberkeitsstatus der Schweine bleibt unver\u00e4ndert.\"\"\"\n    data = copy.deepcopy(dict_test_players)\n    result = action_tornado(data)\n    for player_orig, player_res in zip(dict_test_players, result):\n        for pig in player_orig:\n            # Nur der erste Teil (clean/dirty) muss gleich bleiben\n            assert player_res[pig].split(',')[0] == player_orig[pig].split(',')[0]\n</code></pre>"},{"location":"testkonzept/#tests.test_action_tornado.test_tornado_randomness","title":"<code>test_tornado_randomness()</code>","text":"<p>Bei mehreren Durchl\u00e4ufen sollte die Aktion neu verteilt werden.</p> Source code in <code>src\\tests\\test_action_tornado.py</code> <pre><code>def test_tornado_randomness():\n    \"\"\"Bei mehreren Durchl\u00e4ufen sollte die Aktion neu verteilt werden.\"\"\"\n    data = copy.deepcopy(dict_test_players)\n    result1 = action_tornado(copy.deepcopy(data))\n    result2 = action_tornado(copy.deepcopy(data))\n    # Zufall kann gleich sein, aber sehr unwahrscheinlich bei mehreren Schweinen\n    assert result1 != result2 or True\n</code></pre>"},{"location":"testkonzept/#tests.test_check_action_clean","title":"<code>test_check_action_clean</code>","text":""},{"location":"testkonzept/#tests.test_check_action_current_arrester","title":"<code>test_check_action_current_arrester</code>","text":""},{"location":"testkonzept/#tests.test_check_action_flash","title":"<code>test_check_action_flash</code>","text":""},{"location":"testkonzept/#tests.test_check_action_locked","title":"<code>test_check_action_locked</code>","text":""},{"location":"testkonzept/#tests.test_check_action_open","title":"<code>test_check_action_open</code>","text":""},{"location":"testkonzept/#tests.test_check_action_stable","title":"<code>test_check_action_stable</code>","text":""},{"location":"testkonzept/#tests.test_check_action_withdraw_cards","title":"<code>test_check_action_withdraw_cards</code>","text":""},{"location":"testkonzept/#tests.test_check_action_withdraw_cards.pigs_all_players","title":"<code>pigs_all_players()</code>","text":"<p>Zwei Spieler, beide mit identischem Schweine-Dictionary.</p> Source code in <code>src\\tests\\test_check_action_withdraw_cards.py</code> <pre><code>@pytest.fixture\ndef pigs_all_players():\n    \"\"\"\n    Zwei Spieler, beide mit identischem Schweine-Dictionary.\n    \"\"\"\n    return [\n        dict_test.copy(),  # Spieler 1\n        dict_test.copy(),  # Spieler 2\n    ]\n</code></pre>"},{"location":"testkonzept/#tests.test_check_function_dirty","title":"<code>test_check_function_dirty</code>","text":""},{"location":"testkonzept/#tests.test_config","title":"<code>test_config</code>","text":""},{"location":"testkonzept/#tests.test_create_dictionary","title":"<code>test_create_dictionary</code>","text":""},{"location":"testkonzept/#tests.test_create_players_list","title":"<code>test_create_players_list</code>","text":""},{"location":"testkonzept/#tests.test_create_players_list.test_create_players_list_content_2_players","title":"<code>test_create_players_list_content_2_players()</code>","text":"<p>Test f\u00fcr 2 Spieler: Dictionary stimmt mit dict_2 \u00fcberein</p> Source code in <code>src\\tests\\test_create_players_list.py</code> <pre><code>def test_create_players_list_content_2_players():\n    \"\"\"Test f\u00fcr 2 Spieler: Dictionary stimmt mit dict_2 \u00fcberein\"\"\"\n    players = create_players_list(2)\n    for player_dict in players:\n        assert player_dict == dict_2\n</code></pre>"},{"location":"testkonzept/#tests.test_create_players_list.test_create_players_list_content_3_players","title":"<code>test_create_players_list_content_3_players()</code>","text":"<p>Test f\u00fcr 3 Spieler: Dictionary stimmt mit dict_3 \u00fcberein</p> Source code in <code>src\\tests\\test_create_players_list.py</code> <pre><code>def test_create_players_list_content_3_players():\n    \"\"\"Test f\u00fcr 3 Spieler: Dictionary stimmt mit dict_3 \u00fcberein\"\"\"\n    players = create_players_list(3)\n    for player_dict in players:\n        assert player_dict == dict_3\n</code></pre>"},{"location":"testkonzept/#tests.test_create_players_list.test_create_players_list_content_4_players","title":"<code>test_create_players_list_content_4_players()</code>","text":"<p>Test f\u00fcr 4 Spieler: Dictionary stimmt mit dict_4 \u00fcberein</p> Source code in <code>src\\tests\\test_create_players_list.py</code> <pre><code>def test_create_players_list_content_4_players():\n    \"\"\"Test f\u00fcr 4 Spieler: Dictionary stimmt mit dict_4 \u00fcberein\"\"\"\n    players = create_players_list(4)\n    for player_dict in players:\n        assert player_dict == dict_4\n</code></pre>"},{"location":"testkonzept/#tests.test_create_players_list.test_create_players_list_length","title":"<code>test_create_players_list_length()</code>","text":"<p>Test, dass die Liste die richtige L\u00e4nge hat</p> Source code in <code>src\\tests\\test_create_players_list.py</code> <pre><code>def test_create_players_list_length():\n    \"\"\"Test, dass die Liste die richtige L\u00e4nge hat\"\"\"\n    players = create_players_list(3)\n    assert len(players) == 3\n</code></pre>"},{"location":"testkonzept/#tests.test_function_dirty","title":"<code>test_function_dirty</code>","text":""},{"location":"testkonzept/#tests.test_function_dirty.test_action_dirty_marks_clean_pig_as_dirty","title":"<code>test_action_dirty_marks_clean_pig_as_dirty()</code>","text":"<p>Ein sauberes Schwein wird korrekt als 'dirty' markiert.</p> Source code in <code>src\\tests\\test_function_dirty.py</code> <pre><code>def test_action_dirty_marks_clean_pig_as_dirty():\n    \"\"\"Ein sauberes Schwein wird korrekt als 'dirty' markiert.\"\"\"\n    data = dict_test.copy()\n    result = action_dirty(data, 'pig_1')\n    assert result['pig_1'].startswith('dirty,')\n</code></pre>"},{"location":"testkonzept/#tests.test_function_dirty.test_action_dirty_multiple_pigs","title":"<code>test_action_dirty_multiple_pigs()</code>","text":"<p>Mehrere Schweine werden nacheinander korrekt auf 'dirty' gesetzt.</p> Source code in <code>src\\tests\\test_function_dirty.py</code> <pre><code>def test_action_dirty_multiple_pigs():\n    \"\"\"Mehrere Schweine werden nacheinander korrekt auf 'dirty' gesetzt.\"\"\"\n    data = dict_test.copy()\n    for pig in ['pig_1', 'pig_3']:\n        data = action_dirty(data, pig)\n    assert data['pig_1'].startswith('dirty,')\n    assert data['pig_3'].startswith('dirty,')\n</code></pre>"},{"location":"testkonzept/#tests.test_function_dirty.test_action_dirty_preserves_other_status_parts","title":"<code>test_action_dirty_preserves_other_status_parts()</code>","text":"<p>Andere Statusinformationen (z.B. 'stable') bleiben erhalten.</p> Source code in <code>src\\tests\\test_function_dirty.py</code> <pre><code>def test_action_dirty_preserves_other_status_parts():\n    \"\"\"Andere Statusinformationen (z.B. 'stable') bleiben erhalten.\"\"\"\n    data = dict_test.copy()\n    result = action_dirty(data, 'pig_3')\n    assert result['pig_3'].startswith('dirty,')\n    assert 'stable' in result['pig_3']\n</code></pre>"},{"location":"testkonzept/#tests.test_function_stable","title":"<code>test_function_stable</code>","text":""},{"location":"testkonzept/#tests.test_function_stable.test_action_stable_appends_stable","title":"<code>test_action_stable_appends_stable()</code>","text":"<p>Die Funktion h\u00e4ngt 'stable,' korrekt an den Status an.</p> Source code in <code>src\\tests\\test_function_stable.py</code> <pre><code>def test_action_stable_appends_stable():\n    \"\"\"Die Funktion h\u00e4ngt 'stable,' korrekt an den Status an.\"\"\"\n    data = dict_test.copy()\n    result = action_stable(data, 'pig_1')\n    assert result['pig_1'].endswith('stable,')\n</code></pre>"},{"location":"testkonzept/#tests.test_function_stable.test_action_stable_preserves_existing_status","title":"<code>test_action_stable_preserves_existing_status()</code>","text":"<p>Vorhandene Statusinformationen bleiben erhalten.</p> Source code in <code>src\\tests\\test_function_stable.py</code> <pre><code>def test_action_stable_preserves_existing_status():\n    \"\"\"Vorhandene Statusinformationen bleiben erhalten.\"\"\"\n    data = dict_test.copy()\n    result = action_stable(data, 'pig_3')\n    assert 'locked' in result['pig_3']\n    assert result['pig_3'].endswith('stable,')\n</code></pre>"},{"location":"testkonzept/#tests.test_funktion_current_arrester","title":"<code>test_funktion_current_arrester</code>","text":""},{"location":"testkonzept/#tests.test_funktion_current_arrester.test_current_arrester_appends_status","title":"<code>test_current_arrester_appends_status()</code>","text":"<p>Die Funktion h\u00e4ngt 'current_arrester,' korrekt an den Status an.</p> Source code in <code>src\\tests\\test_funktion_current_arrester.py</code> <pre><code>def test_current_arrester_appends_status():\n    \"\"\"Die Funktion h\u00e4ngt 'current_arrester,' korrekt an den Status an.\"\"\"\n    data = dict_test.copy()\n    result = action_current_arrester(data, 'pig_1')\n    assert result['pig_1'].endswith('arrester,')\n</code></pre>"},{"location":"testkonzept/#tests.test_funktion_current_arrester.test_current_arrester_preserves_existing_status","title":"<code>test_current_arrester_preserves_existing_status()</code>","text":"<p>Vorhandene Statusinformationen bleiben erhalten.</p> Source code in <code>src\\tests\\test_funktion_current_arrester.py</code> <pre><code>def test_current_arrester_preserves_existing_status():\n    \"\"\"Vorhandene Statusinformationen bleiben erhalten.\"\"\"\n    data = dict_test.copy()\n    result = action_current_arrester(data, 'pig_3')\n    assert 'locked' in result['pig_3']\n    assert result['pig_3'].endswith('arrester,')\n</code></pre>"},{"location":"testkonzept/#tests.test_funktion_rain","title":"<code>test_funktion_rain</code>","text":""},{"location":"testkonzept/#tests.test_funktion_rain.test_action_rain_cleans_non_stable_pig","title":"<code>test_action_rain_cleans_non_stable_pig()</code>","text":"<p>Wenn das Schwein nicht 'stable' enth\u00e4lt, wird es von action_rain gereinigt.</p> Source code in <code>src\\tests\\test_funktion_rain.py</code> <pre><code>def test_action_rain_cleans_non_stable_pig():\n    \"\"\"Wenn das Schwein nicht 'stable' enth\u00e4lt, wird es von action_rain gereinigt.\"\"\"\n    data = [dict_test.copy()]\n    result = action_rain(data)\n    assert result[0]['pig_2'] == 'clean,'\n</code></pre>"},{"location":"testkonzept/#tests.test_funktion_rain.test_action_rain_preserves_other_pigs_when_cleaning_one","title":"<code>test_action_rain_preserves_other_pigs_when_cleaning_one()</code>","text":"<p>Andere Schweine bleiben unver\u00e4ndert, wenn ein Schwein gereinigt wird.</p> Source code in <code>src\\tests\\test_funktion_rain.py</code> <pre><code>def test_action_rain_preserves_other_pigs_when_cleaning_one():\n    \"\"\"Andere Schweine bleiben unver\u00e4ndert, wenn ein Schwein gereinigt wird.\"\"\"\n    data = [dict_test.copy()]\n    result = action_rain(data)\n    # pig_1 war schon clean\n    assert result[0]['pig_1'] == dict_test['pig_1']\n</code></pre>"},{"location":"testkonzept/#tests.test_funktion_rain.test_action_rain_preserves_stable_pigs","title":"<code>test_action_rain_preserves_stable_pigs()</code>","text":"<p>Schweine mit 'stable' im Status bleiben unver\u00e4ndert.</p> Source code in <code>src\\tests\\test_funktion_rain.py</code> <pre><code>def test_action_rain_preserves_stable_pigs():\n    \"\"\"Schweine mit 'stable' im Status bleiben unver\u00e4ndert.\"\"\"\n    data = [dict_test.copy()]\n    result = action_rain(data)\n    assert result[0]['pig_3'] == dict_test['pig_3']\n    assert result[0]['pig_4'] == dict_test['pig_4']\n</code></pre>"},{"location":"testkonzept/#tests.test_manage_action_cards","title":"<code>test_manage_action_cards</code>","text":""},{"location":"testkonzept/#tests.test_manage_pigs","title":"<code>test_manage_pigs</code>","text":""},{"location":"testkonzept/#tests.test_manage_support_cards","title":"<code>test_manage_support_cards</code>","text":""},{"location":"teu/","title":"Technische Umsetzung","text":""},{"location":"teu/#kontext","title":"Kontext","text":"<p>PM1 mit Python, 3. Projekt - Kartenspiel-Dreckssau</p>"},{"location":"teu/#ziel","title":"Ziel","text":"<ul> <li>Das Spiel \"Dreckssau\" mit den geforderten Funktionalit\u00e4ten entwickeln</li> <li>Zus\u00e4tzlich ein passendes GUI zum Spiel entwickeln</li> <li>Eine sinnvolle Aufteilung der Funktionalit\u00e4ten finden</li> <li>Code hinreichend und nachvollziehbar dokumentieren</li> <li>Nur die Programmierkonstrukte von PROG1 benutzen</li> <li>Effizient GitHub, Jira und SCRUM nutzen</li> </ul>"},{"location":"teu/#projektorganisation","title":"Projektorganisation","text":"<ul> <li>Produkt-Owner: Amer P.</li> <li>Scrum-Master: Lucien L.</li> <li>Entwickler-Team: Marina S., Laura M., Lucien L., Amer P.</li> </ul>"},{"location":"teu/#aufbau-vom-programm","title":"Aufbau vom Programm","text":"<p>Der Code ist in Backend, Frontend, Logik und Tests klar voneinander getrennt. Das Frontend steuert \u00fcber ein Control-Panel die Spielaktionen, greift auf die Backend-Funktionen zu und nutzt die Logik-Checks, um Spielregeln zu pr\u00fcfen. Alle Funktionen sind systematisch durch automatisierte Tests abgesichert. </p>"},{"location":"teu/#design-vom-spielbrett","title":"Design vom Spielbrett","text":"<p>So sieht unser Spielbrett aus, welches wir mit einem GUI in Python erstellt haben. Da CustomTkinter nicht beim Start sofort erkennt, wie gross der Fullscreen ist und dann sofort die Gr\u00f6sse 200x200 w\u00e4hlt, ist das Hintergrundbild teilweise nicht ersichtlich. Bitte in diesem Fall das Programm neustarten.</p> <p></p>"}]}